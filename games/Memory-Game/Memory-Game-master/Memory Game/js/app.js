
//global declaration of variables
let minutes = 0, seconds = 0;
let time = 0;
let cardcount = 0;
let temparray = [];
let moves = 0;
let matchcounter = 0;

//cards array
const cardlist = [
    // TODO: add other cards in list
    'fa-headphones', 'fa-headphones',
    'fa-desktop', 'fa-desktop',
    'fa-anchor', 'fa-anchor',
    'fa-database', 'fa-database',
    'fa-satellite-dish', 'fa-satellite-dish',
    'fa-atom', 'fa-atom',
    'fa-infinity', 'fa-infinity',
    'fa-apple-alt', 'fa-apple-alt'

]; 


/**
* @description function to generate html for each and every cards when htmlDisplay called by displayBoard function
* @param code is used to map every value in html code passed by displayBoard function 
* @returns returns generated html to displayBoard function 
*/  
function htmlDisplay(code) {
    return `<div class="col col-xl-3 col-lg-3 col-md-3 col-sm-3 col-xs-3 mb-4"> <div class="cards"><i class="fas ${code}"></i></div></div>`;
}


/**
* @description list of card generated by displayBoard function and displayed randomly every time using shuffle function
*/
function displayBoard() {

    var gameboard = document.querySelector('.gameboard');
    var c = shuffle(cardlist).map(function (card) {
        return htmlDisplay(card); //invoke htmlDisplay function to generate html code
    });
    gameboard.innerHTML = c.join(' '); //inserting dynamically generated html to gameboard for display 

} displayBoard();


// Shuffle function
function shuffle(array) {
    var currentIndex = array.length, temporaryValue, randomIndex;

    while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }

    return array;
}


//global declaration for dom elements
let cardsarray = document.querySelectorAll('.cards');
let timerclock = document.querySelector('.timerclock');
let xscores = document.getElementById('prescore');

//retrieve local storage of highscore data
let previousScore = localStorage.getItem('xscore');
xscores.innerText = previousScore;//display previous score of the player 


/**
* @description startGame function invokes when each and every card clicked 
* @var variablecardscount counter increment when every cards has been clicked
* @var cardscount counter decrement when same card is clicked
* @array temparray is used to push only two cards  
*/
function startGame() {

    cardsarray.forEach(function (singlecard) {
        singlecard.addEventListener('click', function (e) {
            cardcount += 1;
            if (cardcount <= 2) {

                if (singlecard.classList.contains('cardsopen')) { //condition for same card clicked

                    cardcount -= 1; //cardcount decreases by 1 

                } else {

                    singlecard.classList.add('cardsopen'); //open cards if it is not a same card
                    temparray.push(singlecard); //push in to array

                    if (cardcount === 2) { 
                        matchingCards(); //check for matching of two cards in the temparray
                        actionTaken(); //function to increment counter of moves 
                        scoreBoard(); //function to display popup after final cards matched
                        
                    }

                }

            }

        });
    });
} startGame();


/**
* @description function for matching of two cards in temparray if matches stay open otherwise closecards at 500ms 
* @var matchcounter increments to 2 after two cards matched it is used to invoke scoreBoard function till value 16  
* @array temparray is used to matching of two cards  
*/
function matchingCards() { // called by startGame function

    if (temparray[1].firstElementChild.classList.item('1') === temparray[0].firstElementChild.classList.item('1')) {

        temparray[0].classList.add('maching'); //add matching class to card 1 
        temparray[1].classList.add('maching'); //add matching class to card 2
        cardcount = 0; //empty cardcount after two cards matched
        temparray = []; //empty temparray after two cards matched
        matchcounter += 2; //deck contains 16 cards for every match of 2 cards matchcounter increments 

    } else {
        
        setTimeout(function () {
            
            closeCards(); //invokes closeCards function to close the opening unmatched card

        }, 500); //close cards after 500 ms

    }
}


/**
* @description function for closing of two unmatched cards and called by startGame function
* @var cardscount reset to 0 if cards unmatched  
* @array reset temarray if cards unmatched 
*/
function closeCards() {

    cardsarray.forEach(function (singlecard) { 
        singlecard.classList.remove('cardsopen'); //close unmatched cards in 500ms
        cardcount = 0; //empty cardcount after two cards unmatched
        temparray = []; //empty temparray after two cards unmatched
    });

}

/**
* @description actionTaken function used to calculate every move taken by the user and called by starGame function
* @variable moves is incremented when user click on each and every card
*/
function actionTaken() {

    moves += 1; //increment by 1 when a card is clicked
    document.querySelector('.action').innerHTML = moves; //reflect moves taken by user in html view

}


/**
* @description scoreBoard function used to create popup to display final score, timetaken, star rating of player. 
* @var modalrating is used to insert star rating html in the popup display as per the star rating of timerClock function
* @var finalscore is used to calculate score to display on popup display using moves and seconds taken by the player
* @var matchcounter incremented by 2 for every 2 cards matched finally arrives at scoreBoard function when matchcounter becomes 16
*/
function scoreBoard() { //scoreBoard function called by startGame function 

    if (matchcounter === 16) { //matchcounter incremented in matchCards function and matches at the final match of 2 cards 2 * 8 = 16 

        let finalscore = 0, modalrating; //score and star rating variables declaration
        let starrating = document.querySelector('.starrating');
        let rating = document.querySelector('.rate').childNodes; //accessing childNodes in dom to find star rating which calculated in timerClock function
        let score = document.querySelector('.score'); //score variable for the player is displayed in the popup modal.
        const modal = document.getElementById('modal');//popup modal variable

        (minutes > 0) ? timerclock.innerHTML = (minutes + " : " + seconds + "sec").toString() : timerclock.innerHTML = seconds; //calculating time taken by the user to finish the game.

        if (rating[3].classList.contains("rating") && rating[5].classList.contains("rating") && rating[7].classList.contains("rating")) { //3 star rating
            modalrating = '<i class="fa fa-star rating"></i><i class="fa fa-star rating"></i><i class="fa fa-star rating"></i>';
        } else if (rating[5].classList.contains("rating") && rating[7].classList.contains("rating")) { //2 star rating
            modalrating = '<i class="fa fa-star norating"></i><i class="fa fa-star rating"></i><i class="fa fa-star rating"></i>';
        } else if (rating[7].classList.contains("rating")) { //1 star rating
            modalrating = '<i class="fa fa-star norating"></i><i class="fa fa-star norating"></i><i class="fa fa-star rating"></i>';
        } else { //nostar rating
            modalrating = '<i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>'; 
        }

        (moves <= 12 && seconds <= 30) ? finalscore += 100 : (moves <= 16 && seconds <= 50) ?
                                         finalscore += 75 : finalscore += 50; //final score calculation
                                         
        starrating.innerHTML = modalrating; //rating display
        score.innerHTML = finalscore; //score display
        modal.style.display = "block"; //popup modal display

        localStorage.setItem('xscore', finalscore);//save score in local storage.
    }

}


/**
* @description timerClock function starts when the game starts 
*  - here we dynamically calculate stars using moves taken by the user used to display when user finish the game
*  - calculate time conversion to minutes and seconds used to display when user finish the game
* @var time gets incremented every 1000ms
* @var moves no of moves taken by the user is used to calculate star rating
*/
function timerClock() {

    setInterval(function () {

        var ratings = document.querySelector('.rate').childNodes; //star display on the gameboard
        time = time + 1; //time incremented for every 1000ms
        
        if(time >= 60) {
        minutes = (time / 60).toFixed();
        }
        seconds = (time % 60); //time taken to finish the game is calculated

        (moves === 12) ? ratings[3].classList.remove("rating") : (moves === 16) ? //after 16 moves decrease 1 star
                         ratings[5].classList.remove("rating") : (moves === 20) ? //after 20 moves decrease 2 star
                         ratings[7].classList.remove("rating") : console.log("game is running"); //decrease 3 star

    }, 1000); 

} timerClock();


/**
* @description reLoad function used to reload entire game.
*/
function reLoad() {

    location.reload();

}
